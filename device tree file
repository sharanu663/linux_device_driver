





Nordic build system using zephyr os :

Kconfig    -------->|
                    |
                    |---------> Cmake -------->Ninja-------->gcc
                    |
Device tree ------->|  

On:ESP32:
build command 
west build -p always -b <board_name>  -- -DDTC_OVERLAY_FILE=boards/esp32.overlay (path of .overlay file ) 

 below mention command after build command  whatever giving that paramters going to cmake, not west
here -DDTC_OVERLAY_FILE=boards/esp32.overlay (path of .overlay file ) command going to cmake file

without west tool how to build:
cmake -G "Ninja" -DBOARD=<board_name> -DDTC_OVERLAY_FILE=boards/esp32.overlay -B build -S.
build command:
cmake --build build

/{

    aliases{
        my-led = &led0;          //here label refernce of led0 and giving aliases name as my-led
    };
    leds{
        compatible = "gpio-leds";
        led0: d13 {
           gpios = <&gpio0 13 GPIO_ACTIVATE_HIGH>;
        };

     };
};


another example of esp32 board :
our application creating boards folder and create a file esp32s3_devkitc.overlay under board directory itself
we are changing the some of the parmeter or setup for device tree

/{

    aliases{
        my-led = &button_1           //here label refernce of led0 and giving aliases name as my-led
    };
    buttons{
        compatible = "gpio-keys";
        debounce-interval-ms = <50>  // here we are changing the default debounce time
        polling-mode;

        button_1: d5 {
           gpios = <&gpio0 5 (GPIO_ACTIVATE_LOW | GPIO_PULL_UP)>;
        };

     };
};



west is meta tool here that tells zephyr we want to build our project and it's going to call the CMake in order to make that happen


if getting build issue:like permissoin 
Set-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy Unrestricted -Force



app
|          |---> include --> test.h   
|---> src---
|          |----> src----> test.c and main.c
CMakeLists.txt
prj.conf


cmake example above file structure:

cmake_minimum_required(VERSION 3.20.0)

#name the project
project (hello_word
         VERSION 1.0
         DESCRIPTION "the classic"
         LANGUAGES C)
#Create a static library target named "my_lib"
add_library(my_lib
    STATIC
    src/my_lib.c)

#set the include directories for the library.PUBLIC adds the
#directory to the search path for any target that link to this library.
target_include_directories(my_lib PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/include)

#create an executable target with the same name as the project name
add_executable(${PROJECT_NAME} src/main.c)

#link the library to the executable. PRIVATE means that the library is not 
# exposed to targets that depend on this target.
target_link_libraries(${PROJECT_NAME} PRIVATE my_lib)



build:
-S is source path, -B create build directory  , -G tell to generate Ninja build file
cmake -S . -B build -G "Ninja"

executable file  :
cmake --build build

pratical_zephyr_dt
https://interrupt.memfault.com/blog/practical_zephyr_dt

modern-cmake guid:
https://cliutils.gitlab.io/modern-cmake/README.html

yaml:
https://spacelift.io/blog/yaml


device tree bindings :
https://www.kernel.org/doc/Documentation/devicetree/bindings/

device tree spection document tell abt systex:
https://github.com/devicetree-org/devicetree-specification/releases/tag/v0.4



Below details about stm32f401er device tree :
dts file:
/home/menaka/zephyrproject/zephyr/dts/arm/st/f4/stm32f4.dtsi
/home/menaka/zephyrproject/zephyr/dts/arm/st/f4/stm32f401Xe.dtsi

using : compatible = "st,stm32f4-adc", "st,stm32-adc";
name search for binding file

/home/menaka/zephyrproject/zephyr/dts/bindings/adc/st,stm32f4-adc.yaml

/home/menaka/zephyrproject/zephyr/dts/bindings/adc/st,stm32-adc.yaml
|->/home/menaka/zephyrproject/zephyr/dts/bindings/adc/adc-controller.yaml
    |-> /home/menaka/zephyrproject/zephyr/dts/bindings/base/base.yaml
          |-> /home/menaka/zephyrproject/zephyr/dts/bindings/base/pm.yaml
|->/home/menaka/zephyrproject/zephyr/dts/bindings/pinctrl/pinctrl-device.yaml

driver adc :
compatible: "st,stm32-adc" is match to  #define DT_DRV_COMPAT st_stm32_adc
/home/menaka/zephyrproject/zephyr/drivers/adc/adc_stm32.c
/home/menaka/zephyrproject/zephyr/include/zephyr/drivers/adc.h
  |-> /home/menaka/zephyrproject/zephyr/include/zephyr/device.h



Below example about esp32 driver create :

modules
|->button
    |->drivers
       |->button
           ->button.h , button.c


button.h

#ifndef ZEPHYR_DRIVERS_H
#define ZEPHYR_DRIVERS_H

#include <zephyr/drivers/gpio.h>


// we declare our own api function
struct button_api {
   int (get*)(const struct device *dev,unit8_t *state);

};

//configuration
struct button_config {
  struct gpio_dt_spec btn;
  uint32_t id;

};


#endif 




button..c


//we need to create compatible field symbol or string  that lets zephyr knows that this is driver code for the compatible 
//listed in the binding yml file as well as the compatible property in the device tree  
//ties to the 'compatible = "custom,button" ' node in the device tree

#define DT_DRV_COMPAT custom_button


#include  <error.h>
#include "button.h"

#include <zephyr/logging/log.h>

// Enable logging at CONFIG_LOG_DEFAULT_LEVEL 
LOG_MODULE_REGISTER(button)  // here we registering the modules


//--------------------------------------------------------------
 // private function 
static int button_init(const struct device *dev);  // this function get called after boot and initalize the module 
static int button_state_init(const struct device *dev,uint8_t *state);

//-----------------------------------------------------------------------------


static int button_init(const struct device *dev)
{
    int ret;

   // cast device.config (declared const void *) to our button's config
  const struct button_config *cfg = (const struct button_config *)dev->config;

 // get the button struct from the config
  const struct gpio_dt_spec *btn = &cfg->btn;

  LOG_DBG("initalizing button (instance ID = %u)\n", cfg->id);

  if(gpio_is_ready_dt(btn)){
     LOG_ERR("GPIO is not ready/n");
     return -ENODEV;

  }
  ret = gpio_pin_configure_dt(btn,GPIO_INPUT);
  if(ret < 0) {
     LOG_ERR("GPIO configuration is failed/n");
     return -ENODEV;

  }
  return 0;

}

static int button_state_init(const struct device *dev,uint8_t *state)
{
       int ret;

   // cast device.config (declared const void *) to our button's config
  const struct button_config *cfg = (const struct button_config *)dev->config;

 // get the button struct from the config
  const struct gpio_dt_spec *btn = &cfg->btn;


  ret = gpio_pin_get_dtc(btn);
  if(ret < 0) {
     LOG_ERR("GPIO is not ready failed/n");
     return ret;
   }else {

      *state = ret;
  }
}



//---------------------------------------------------------------------------

// devicetree handling






























1) Some hardware busses provide "discoverability" mechanisms: means that we can identify which device is connected on this busess
EX: PC(e),USB
Device can be enumerated and identfied at runtime
Concept of vendor ID,product ID,device class,etc

2) Some hardware busses do not provide "discoverability" mechanisms: means that we can't identify which device is connected on this busess
   Ex: i2c,SPI,1wire
  How does operating system get to know what is topology of hardware?
 Allow the operating system or bootloader to know things like : provide details of the device that used like pherephiral,clock, number of cores

  how to provide board the details to operating system ? Directly in the OS/bootloader
  1) using compiled data structures,typically in C
  2) How it was done on most embedded platforms in linux,U-Boot
  3) Considered not maintainable/sustainable on ARM32, which motivated the move to another solution.
   






device tree will be present on this path: "arch/ARCH/boot/dts"

Device tree : A tree structure describing the hardware is writtern by a developer
in a device tree source file(.dts)
processed by the device tree compiler (dtc)
produces a more efficient representation: device tree Blob, dtb
Additional C preprocessor pass 


Device tree files are not monolithic, they can be split in several files,
including each other.

Device tree inheritance :

.dtsi files are included files,while .dts files are final device trees
  only .dts files are accepted as input to dtc
Typically, .dtsi will contain
   1) definitions of SOC-level information
   2) definitions common to several boards
the .dts files contains the board-level infomation
Allows an including file to override value specified by an included file
uses the C pre-processor #include directive








Now used most Embedded-oriented CPU architecture that run Linux: ARM64,RISC-V,ARM32,
 Power PC,MIPS,etc



     I/P                         compiler                        O/P 
Device tree source (dts)---> Device tree compiler (dtc) ----> Device tree Blob(.dtb)

Disadavantage is : Considered not maintainable/sustainable on ARM32, which motivated the
                    move to another solution.
that is called "ACPI" tables : is support on 0x86 system and subset of ARM64 platforms
                        Tables provided by the Firmware on BIOS in 0x86 system, UFI also


Node name is in the format systex : node-name@unit-address

node-name:
The node-name component specifies the name of the node. It shall be 1 to 31 characters in length

 Character
 0-9                digit
 a-z               lowercase letter
 A-Z               uppercase letter
 ,                 comma
 .                 period
 _                 underscore
 +                 plus sign
 -                  dash
node-name should mention in the generic name (like what type peripherals, protocal name)

 • adc
 • accelerometer
 • air-pollution-sensor
 • atm
 • audio-codec
 • audio-controller
 • backlight
 • bluetooth
 • bus
 • cache-controller
 • camera
 • can
 • charger
 • clock
 • clock-controller
 • co2-sensor
 • compact-flash
 • cpu
 • cpus
 • crypto
 • disk
 • display
 • dma-controller
 • dsi
 • dsp
 • eeprom
 • efuse
 • endpoint
 • ethernet
 • ethernet-phy
 • fdc
 • flash
 • gnss
 • gpio
 • gpu
 • gyrometer
 • hdmi
 • hwlock
 • i2c
 • i2c-mux
 • ide
 • interrupt-controller
 • iommu
 • isa
 • keyboard
 • key
 • keys
 • lcd-controller
 • led
 • leds
 • led-controller
 • light-sensor
 • lora
 •magnetometer
 •mailbox
 •mdio
 •memory
 •memory-controller
 •mmc
 •mmc-slot
 •mouse
 • nand-controller
 • nvram
 • oscillator
 • parallel
 • pc-card
 • pci
 • pcie
 • phy
 • pinctrl
 • pmic
 • pmu
 • port
 • ports
 • power-monitor
 • pwm
 • regulator
 • reset-controller
 • rng
 • rtc
 • sata
 • scsi
 • serial
 • sound
 • spi
 • spmi
 • sram-controller
 • ssi-controller
 • syscon
 • temperature-sensor
 • timer
 • touchscreen
 • tpm
 • usb
 • usb-hub
 • usb-phy
 • vibrator
 • video-codec
 • vme
 •watchdog
 •wif



unit-address: basically tell about base address of the component or any peripherls in the board 
1) The unit-address component of the nameis specific to the bus type on which the node sits.
2) The unit-address must match the first address specified in the reg property of the node.
   If the node has no reg property, the @unit-address must be omitted(negalate) and the node-name alone differentiates the
   node from other nodes at the same level in the tree.
3) In the case of node-name without an @unit-address the node-name shall be unique from any property names at the same
   level in the tree.
4) The root node does not have a node-name or unit-address. It is identified by a forward slash (/).


different types of properties:
standard and non-standard property (custom property)
  1) standard property are thos which is explained by the specification
      and the deivce-binding documentation
  2) custom properties are specific to a particular vendor or organization which
      is not documented by the specification.
  

uses of compatible property
 1) machine identification and initialization 
 2) match and load the appropriate driver for the device

using compatible name  we can find out the driver and call the prob function when kernel going to initialize 


In the linux source tree : linux-5.4/arch/arm/boot/dts
      drivers:   linux-5.4/drivers/i2c/busses/i2c-omap.c 
eeprom  device :   linux-5.4/drivers/misc/eeprom/at24.c


device tree bindings:
How do you know the whic property name and value pair should be used to
 describe a node in the device tree?
     device tree binding document. the driver writer must document these details
  linux-5.4/Documentation/devicetree/bindings/i2c/i2c-omap.txt 
 give overview information all the properties  

Device tree bindings -points to remember:
case 1 :  When the driver is already available in the linux kernel for the deivce 'x',
but you just need to add device 'x' entry in the device tree then you must consult 'x' driver binding document which
guides you through creating device tree node for device 'x'.

check driver is present or not :
ex: lm75 temprature sensor:
linux-5.4/Documentation/devicetree/bindings/hwmon/lm75.txt 
linux-5.4/drivers/hwmon/lm75.c


Case2 : when the driver is not availabel for the device 'x', then you should write you own driver, you should
decide what properties to use(could be a combination of standard and non-standard property),
you should then provide the deive tree binding document describing what are all the properties and compatible strings a device tree write nust include.






ex: 
(master)
   i2c-0 <----------|
                    |------------ slave device 1 (slave address is 0x24)
                    |------------ slave device 2 (slave address is 0x50)
for example:
In soc level dtsi file will get i2c0 related information 
 /{
    i2c0: i2c@44e0b000{                  // base address of i2c0
         compatible = "ti,omap4-i2c";
         #address-cell = <1>;
         #size-cell = <0>;
        ti,hwmods = <70>;
         reg = <44e0b000 0x1000>;          // base address of i2c0 and offset
         interrupts = <70>;
         status = "disabled";
     };

  };

now we to provide what are deivce is connected on this bus and if you want changes anything you can change parameter values
how to asscess? using label name through we can access  what is label name here? see above soc level dtsi file :  i2c0 
dts file

  /{
 
     &i2c0{

          status = "okay";
          clock-frequency = <40000>;
          tps: tps@24 {        // child node of i2c0 and 24 is slave1 adress
             reg = <0x24>;      // slave 1 address
             };

           baseboard_eeprom: baseboard_eeprom@50 {        // child node of i2c0 and 50 is slave2 adress
             reg = <0x50>;      // slave 2 address
             };
      };
   };

ex: foo.dts
   /dts-v1/ ; 
 / {
        welcome = <0xBADCADFE>;
        bootlin {
                    webinar = "great";
                    demo = <1>,<2>,<3>;
   };

compile command : dtc -I dts -O dtb -o foo.dtb foo.dts

/{
    node@0{
         a-string-property = "A String";
          a-string-list-property = "frist String","second string";
          a-byte-data-property = [0x01,0x02,0x34,0x54];  #---> bytestring

             child-node@0 {
                  frist-child-property;
                  second-child-property = <1>;
                  a-reference-to-something = <&node1>;
              };

               child-node@1 {
                };
           };
   
         node1:node@1 {              
            an-empty-property;
            a-cell-property = <1 2 3 4>;
               
                child-node@1 {
                };
          };
};

1) node@0 -> node is node name, 0-> unit address
2)  properties of node@0
      property name       property value
    a-string-property =     "A String";
    a-string-list-property = "frist String","second string";
    a-byte-data-property = [0x01,0x02,0x34,0x54];
 3) line number 72 is  "node1:" is called as label
 4) a-cell-property = <1 2 3 4>;   // four cells(32 bits values)


another exmple :

/ {

      model = STM32MP157C-DK2 Discovery Board " ; # here you write the modul name of devices which going to support this node
      compatible = "st,stm32mp157c" ,"st,stm32mp157";   //which are board series will support this node
      cpus {......};
      memory@0 {.....};
      chosen {......};
      intc: interrupt-controller@a0021000 {.....};
      soc {
            i2c1: i2c@400120000 {....};
            ethernet0: ethernet@5800a000 {......};
       };
 };

"**) how to overwrite value that is given in .dtsi in default 
     below example we change status "disable" to "okay" using .dts file, final output will get status = "okay"
  ex:  soc.dtsi
      /{ 
        soc {
               usart: serial@5c00000 {
               compatible = "st,stm32h7-uart";
               reg=<0x5c000 0x4000>;
               status = "disable";
                };
           };
       };
   
 board.dts
   #include "soc.dtsi
   /{ 
        soc {
            serial@5c00000 {
            status = "okay";
            };
         };
       };
   
   or
  board.dts
   #include "soc.dtsi 
      &usart {
       status = "okay"; 
       };

compatible propert: it is used by the operating system to find the appropriate
drvier for this device.
when describing real hardware,typical from is vendor,model
special value : simple bus -> bus where all sub nodes are memory-mapped devices

reg : use as memory mapped : <base pyhsical address and size of the memory-mapped register.
ex: reg = <0x5000243 0x03>
if reg using as i2c : address of the device on the I2C bus
 ex: 
    &i2c1 {
        cs4251:cs4251@4 {
         reg = <0x04>;
        };
     };
 in spi:
        &qspi {
        flash1:mx4421213 {
         reg = <1>;
        };
     };


cell concept :
1)Interger values represented as 32-bit integers called cells
2) encoding a 64-bit value requires two cells
3) #address-cells and #size-cells : how many cells are used in sub-nodes
to encode the address and size in the reg property

ex:  soc {
       compatible = "simple-bus";
         #address-cells = <1>;
         #size-cells = <1>;

         i2c@f1001000 {
             reg = <f1001000 0x1000>;
            #address-cells = <1>;
            #size-cells = <0>;
            eeprom@52{
               reg = <0x52>;
            };
         };
     };

   ex:
   soc {
        clkc: clock@f1003000 {
       compatible = "foo,bar-clock";
        reg = <f1003000 0x1000>;
        #clock-cells = <3>;
        };
       i2c@f1001000 {
           clocks = <&clkc 12,24,32>;
        };
  };
       

status : two values "okay" or "ok" and "disabled" 
           "okay" or "ok"  : device is really in use
            "disabled" or ther value : device is not used  




