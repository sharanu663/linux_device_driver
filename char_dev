kernel APIs and utilities to be used in driver code of charcter :
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/cdev.h>
Dynamically register range of char device number:

creation:

alloc_chrdev_region(dev_t *dev,unsigned baseminor,unsigned count,const char *name); //create device number

dev_t dev : output parameter for first assigned number.
unsigned baseminor: first of the requested range of minor numbers
unsigned count: number of minor number required
char *name : name of the associated device or driver


void cdev_init(struct cdev *cdev,const struct file_opertions *fops)   //make a char device registration with the VFS
struct cdev *cdev : structure initialize
struct file_opertions *fops file operation for this device

//add a char device to the kernel VFS
int cdev_add(struct cdev *p,dev_t dev,unsigned count);
struct cdev *p: cdev structure for the device
dev_t dev : first device number for which this device is responsible
unsigned count : number of consecutive minor number crossesponding to this device

class_create();     // create device files
device_create();

Deletion:

unregister_chrdev_region()

cdev_del();

class_destroy();
device_destory();


whenever user space request some opertion then it will for to VFS(virtual file system)
later appropriate function get called.
-------------------------------------------------------------------------------------------
                fd=open("/dev/pcd",O_RDWR);
user space      /dev/pcd  
------------------|-------------------------
kernel space      | 
         --------<-|
         |  VFS |----------> int pcd_open();
         |----- |             pcd_driver
opens a file by creating
a new file object and linking
it to the corresponding
inode object.
--------------------------------------------------------------------------------

struct inode: inode is a VFS data structure that holds general information about a file
and tracks  interaction on an opened file by the user process, each file has is own inode object,
which the filesystem uses to identify the file. each inode object associated with an inode number,
which uniquely identifies the file the filesystem.
inode object is created and stored in memory as and when a new file (regular or device) gets created.
"if any changes in the inode member elements then that will writtern back to disk"


struct file: whenever a file opened a file object is created in kernel space. there will one file 
object for every open of a regular or device file.
stored information abt the interaction b/w an open file and a process
"content not written back to disks unlike inode"

these function get called when user space called open function 

user space           open()
-------------------------------------------------
kernel space       do_sys_open()
                  do_filp_open()  // file object allocation 
                 do_dentry_open()  // default dummy file operation function will called
                  chrdev_open()    // replacing default fops with 'cdev' fops
                 your driver open method()

                       close(fd);
user space           /dev/pcd()
-------------------------------------------------
kernel space     
        |-------|
        |  VFS  | ---------------> int pcd_release();
        |-------|
 Releases the file object.
called when the last reference to 
an open file is closed- that is,
when the f_count field of the file 
object becomes 0.


summary:

when device file gets created:
1) create device file using udev
2) inode object gets created in memory and inode's i_rdev field is initialized with device number
3) inode object's i_fop field is set to dummy default file opertions(def_chr_fops)

when user process executes open system call
1) user invokes open system call on the device file
2) file object get created
3) inode's i_fop gets copied to file object's f_op (dummy file opertions of char device file)
4) open function of dummy default file opertion gets called(chrdev_open)
5) inode object's i_cdev field is initialized with cdev which you added during cdev_add
   (lookup happens using inode->i_rdev field)
6) inode->cdev->fops (this is a real fileoperations of your driver) gets copied to file->f_op
7) file->f_op->open method gets called (read open method of your driver)


macro of dev_t is (uint32_t) 

int minor_no =MINOR(device_nu);   //this macro is will give minor
int major_no = MAJOR(device_nu); // this macro is will give major
MKDEV(int major,int minor);    //it will give device type

macro THIS_MODULE : point to the module that owns this structure; it should usually be initialized
to THIS_MODULE.
this field is used to prevent the module from being unloaded while structure is in use.

copy_to_user()
copy_from_user() 

/*device creation*/
dev_t device_nu

alloc_chrdev_region(&device_nu,0,6,"eeprom");


struct cdev pcd_cdev;        
struct file_opertions pcd_fops;   //this structure will provide the various function (read,write,llseek,etc)
cdev_init(&pcd_cdev,&pcd_fops);

pcd_cdev.ownder = THIS_MODULE;
cdev_add(&pcd_cdev,device_number,1);



















